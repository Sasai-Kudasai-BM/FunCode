package net.skds.jvk.generated.structs;

import java.lang.foreign.Arena;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import net.skds.jvk.StructConstructor;
import net.skds.jvk.VkStructArray;
import net.skds.jvk.annotation.NativeType;
import net.skds.lib2.annotations.AutoGenerated;
import net.skds.lib2.natives.struct.CStruct;

import static java.lang.foreign.ValueLayout.*;
import static net.skds.lib2.natives.SafeLinker.*;
import static java.lang.foreign.MemoryLayout.*;

/**
*<pre>
* C definition:
* struct VkPhysicalDeviceFeatures {
* 	VkBool32 robustBufferAccess;
* 	VkBool32 fullDrawIndexUint32;
* 	VkBool32 imageCubeArray;
* 	VkBool32 independentBlend;
* 	VkBool32 geometryShader;
* 	VkBool32 tessellationShader;
* 	VkBool32 sampleRateShading;
* 	VkBool32 dualSrcBlend;
* 	VkBool32 logicOp;
* 	VkBool32 multiDrawIndirect;
* 	VkBool32 drawIndirectFirstInstance;
* 	VkBool32 depthClamp;
* 	VkBool32 depthBiasClamp;
* 	VkBool32 fillModeNonSolid;
* 	VkBool32 depthBounds;
* 	VkBool32 wideLines;
* 	VkBool32 largePoints;
* 	VkBool32 alphaToOne;
* 	VkBool32 multiViewport;
* 	VkBool32 samplerAnisotropy;
* 	VkBool32 textureCompressionETC2;
* 	VkBool32 textureCompressionASTC_LDR;
* 	VkBool32 textureCompressionBC;
* 	VkBool32 occlusionQueryPrecise;
* 	VkBool32 pipelineStatisticsQuery;
* 	VkBool32 vertexPipelineStoresAndAtomics;
* 	VkBool32 fragmentStoresAndAtomics;
* 	VkBool32 shaderTessellationAndGeometryPointSize;
* 	VkBool32 shaderImageGatherExtended;
* 	VkBool32 shaderStorageImageExtendedFormats;
* 	VkBool32 shaderStorageImageMultisample;
* 	VkBool32 shaderStorageImageReadWithoutFormat;
* 	VkBool32 shaderStorageImageWriteWithoutFormat;
* 	VkBool32 shaderUniformBufferArrayDynamicIndexing;
* 	VkBool32 shaderSampledImageArrayDynamicIndexing;
* 	VkBool32 shaderStorageBufferArrayDynamicIndexing;
* 	VkBool32 shaderStorageImageArrayDynamicIndexing;
* 	VkBool32 shaderClipDistance;
* 	VkBool32 shaderCullDistance;
* 	VkBool32 shaderFloat64;
* 	VkBool32 shaderInt64;
* 	VkBool32 shaderInt16;
* 	VkBool32 shaderResourceResidency;
* 	VkBool32 shaderResourceMinLod;
* 	VkBool32 sparseBinding;
* 	VkBool32 sparseResidencyBuffer;
* 	VkBool32 sparseResidencyImage2D;
* 	VkBool32 sparseResidencyImage3D;
* 	VkBool32 sparseResidency2Samples;
* 	VkBool32 sparseResidency4Samples;
* 	VkBool32 sparseResidency8Samples;
* 	VkBool32 sparseResidency16Samples;
* 	VkBool32 sparseResidencyAliased;
* 	VkBool32 variableMultisampleRate;
* 	VkBool32 inheritedQueries;
* };
*</pre>
**/
@AutoGenerated
public final class VkPhysicalDeviceFeatures extends CStruct {
	
	public static final MemoryLayout MEMORY_LAYOUT = structLayout(
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT,
			JAVA_INT
	);
	private static final int ROBUST_BUFFER_ACCESS_OFFSET = 0;
	private static final int FULL_DRAW_INDEX_UINT32_OFFSET = 4;
	private static final int IMAGE_CUBE_ARRAY_OFFSET = 8;
	private static final int INDEPENDENT_BLEND_OFFSET = 12;
	private static final int GEOMETRY_SHADER_OFFSET = 16;
	private static final int TESSELLATION_SHADER_OFFSET = 20;
	private static final int SAMPLE_RATE_SHADING_OFFSET = 24;
	private static final int DUAL_SRC_BLEND_OFFSET = 28;
	private static final int LOGIC_OP_OFFSET = 32;
	private static final int MULTI_DRAW_INDIRECT_OFFSET = 36;
	private static final int DRAW_INDIRECT_FIRST_INSTANCE_OFFSET = 40;
	private static final int DEPTH_CLAMP_OFFSET = 44;
	private static final int DEPTH_BIAS_CLAMP_OFFSET = 48;
	private static final int FILL_MODE_NON_SOLID_OFFSET = 52;
	private static final int DEPTH_BOUNDS_OFFSET = 56;
	private static final int WIDE_LINES_OFFSET = 60;
	private static final int LARGE_POINTS_OFFSET = 64;
	private static final int ALPHA_TO_ONE_OFFSET = 68;
	private static final int MULTI_VIEWPORT_OFFSET = 72;
	private static final int SAMPLER_ANISOTROPY_OFFSET = 76;
	private static final int TEXTURE_COMPRESSION_ETC2_OFFSET = 80;
	private static final int TEXTURE_COMPRESSION_ASTC__LDR_OFFSET = 84;
	private static final int TEXTURE_COMPRESSION_BC_OFFSET = 88;
	private static final int OCCLUSION_QUERY_PRECISE_OFFSET = 92;
	private static final int PIPELINE_STATISTICS_QUERY_OFFSET = 96;
	private static final int VERTEX_PIPELINE_STORES_AND_ATOMICS_OFFSET = 100;
	private static final int FRAGMENT_STORES_AND_ATOMICS_OFFSET = 104;
	private static final int SHADER_TESSELLATION_AND_GEOMETRY_POINT_SIZE_OFFSET = 108;
	private static final int SHADER_IMAGE_GATHER_EXTENDED_OFFSET = 112;
	private static final int SHADER_STORAGE_IMAGE_EXTENDED_FORMATS_OFFSET = 116;
	private static final int SHADER_STORAGE_IMAGE_MULTISAMPLE_OFFSET = 120;
	private static final int SHADER_STORAGE_IMAGE_READ_WITHOUT_FORMAT_OFFSET = 124;
	private static final int SHADER_STORAGE_IMAGE_WRITE_WITHOUT_FORMAT_OFFSET = 128;
	private static final int SHADER_UNIFORM_BUFFER_ARRAY_DYNAMIC_INDEXING_OFFSET = 132;
	private static final int SHADER_SAMPLED_IMAGE_ARRAY_DYNAMIC_INDEXING_OFFSET = 136;
	private static final int SHADER_STORAGE_BUFFER_ARRAY_DYNAMIC_INDEXING_OFFSET = 140;
	private static final int SHADER_STORAGE_IMAGE_ARRAY_DYNAMIC_INDEXING_OFFSET = 144;
	private static final int SHADER_CLIP_DISTANCE_OFFSET = 148;
	private static final int SHADER_CULL_DISTANCE_OFFSET = 152;
	private static final int SHADER_FLOAT64_OFFSET = 156;
	private static final int SHADER_INT64_OFFSET = 160;
	private static final int SHADER_INT16_OFFSET = 164;
	private static final int SHADER_RESOURCE_RESIDENCY_OFFSET = 168;
	private static final int SHADER_RESOURCE_MIN_LOD_OFFSET = 172;
	private static final int SPARSE_BINDING_OFFSET = 176;
	private static final int SPARSE_RESIDENCY_BUFFER_OFFSET = 180;
	private static final int SPARSE_RESIDENCY_IMAGE2_D_OFFSET = 184;
	private static final int SPARSE_RESIDENCY_IMAGE3_D_OFFSET = 188;
	private static final int SPARSE_RESIDENCY2_SAMPLES_OFFSET = 192;
	private static final int SPARSE_RESIDENCY4_SAMPLES_OFFSET = 196;
	private static final int SPARSE_RESIDENCY8_SAMPLES_OFFSET = 200;
	private static final int SPARSE_RESIDENCY16_SAMPLES_OFFSET = 204;
	private static final int SPARSE_RESIDENCY_ALIASED_OFFSET = 208;
	private static final int VARIABLE_MULTISAMPLE_RATE_OFFSET = 212;
	private static final int INHERITED_QUERIES_OFFSET = 216;
	
	public VkPhysicalDeviceFeatures() {
		this.segment = Arena.ofAuto().allocate(MEMORY_LAYOUT.byteSize());
	}
	
	public VkPhysicalDeviceFeatures(Arena arena) {
		this.segment = arena.allocate(MEMORY_LAYOUT.byteSize());
	}
	
	public VkPhysicalDeviceFeatures(MemorySegment segment, long offset) {
		super(segment, offset);
	}
	
	
	@NativeType("VkBool32")
	public boolean robustBufferAccess() {
		return (int) INT_HANDLE.get(this.segment, this.offset + ROBUST_BUFFER_ACCESS_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures robustBufferAccess(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + ROBUST_BUFFER_ACCESS_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean fullDrawIndexUint32() {
		return (int) INT_HANDLE.get(this.segment, this.offset + FULL_DRAW_INDEX_UINT32_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures fullDrawIndexUint32(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + FULL_DRAW_INDEX_UINT32_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean imageCubeArray() {
		return (int) INT_HANDLE.get(this.segment, this.offset + IMAGE_CUBE_ARRAY_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures imageCubeArray(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + IMAGE_CUBE_ARRAY_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean independentBlend() {
		return (int) INT_HANDLE.get(this.segment, this.offset + INDEPENDENT_BLEND_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures independentBlend(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + INDEPENDENT_BLEND_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean geometryShader() {
		return (int) INT_HANDLE.get(this.segment, this.offset + GEOMETRY_SHADER_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures geometryShader(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + GEOMETRY_SHADER_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean tessellationShader() {
		return (int) INT_HANDLE.get(this.segment, this.offset + TESSELLATION_SHADER_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures tessellationShader(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + TESSELLATION_SHADER_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sampleRateShading() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SAMPLE_RATE_SHADING_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sampleRateShading(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SAMPLE_RATE_SHADING_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean dualSrcBlend() {
		return (int) INT_HANDLE.get(this.segment, this.offset + DUAL_SRC_BLEND_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures dualSrcBlend(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + DUAL_SRC_BLEND_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean logicOp() {
		return (int) INT_HANDLE.get(this.segment, this.offset + LOGIC_OP_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures logicOp(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + LOGIC_OP_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean multiDrawIndirect() {
		return (int) INT_HANDLE.get(this.segment, this.offset + MULTI_DRAW_INDIRECT_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures multiDrawIndirect(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + MULTI_DRAW_INDIRECT_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean drawIndirectFirstInstance() {
		return (int) INT_HANDLE.get(this.segment, this.offset + DRAW_INDIRECT_FIRST_INSTANCE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures drawIndirectFirstInstance(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + DRAW_INDIRECT_FIRST_INSTANCE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean depthClamp() {
		return (int) INT_HANDLE.get(this.segment, this.offset + DEPTH_CLAMP_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures depthClamp(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + DEPTH_CLAMP_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean depthBiasClamp() {
		return (int) INT_HANDLE.get(this.segment, this.offset + DEPTH_BIAS_CLAMP_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures depthBiasClamp(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + DEPTH_BIAS_CLAMP_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean fillModeNonSolid() {
		return (int) INT_HANDLE.get(this.segment, this.offset + FILL_MODE_NON_SOLID_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures fillModeNonSolid(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + FILL_MODE_NON_SOLID_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean depthBounds() {
		return (int) INT_HANDLE.get(this.segment, this.offset + DEPTH_BOUNDS_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures depthBounds(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + DEPTH_BOUNDS_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean wideLines() {
		return (int) INT_HANDLE.get(this.segment, this.offset + WIDE_LINES_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures wideLines(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + WIDE_LINES_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean largePoints() {
		return (int) INT_HANDLE.get(this.segment, this.offset + LARGE_POINTS_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures largePoints(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + LARGE_POINTS_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean alphaToOne() {
		return (int) INT_HANDLE.get(this.segment, this.offset + ALPHA_TO_ONE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures alphaToOne(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + ALPHA_TO_ONE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean multiViewport() {
		return (int) INT_HANDLE.get(this.segment, this.offset + MULTI_VIEWPORT_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures multiViewport(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + MULTI_VIEWPORT_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean samplerAnisotropy() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SAMPLER_ANISOTROPY_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures samplerAnisotropy(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SAMPLER_ANISOTROPY_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean textureCompressionETC2() {
		return (int) INT_HANDLE.get(this.segment, this.offset + TEXTURE_COMPRESSION_ETC2_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures textureCompressionETC2(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + TEXTURE_COMPRESSION_ETC2_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean textureCompressionASTC_LDR() {
		return (int) INT_HANDLE.get(this.segment, this.offset + TEXTURE_COMPRESSION_ASTC__LDR_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures textureCompressionASTC_LDR(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + TEXTURE_COMPRESSION_ASTC__LDR_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean textureCompressionBC() {
		return (int) INT_HANDLE.get(this.segment, this.offset + TEXTURE_COMPRESSION_BC_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures textureCompressionBC(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + TEXTURE_COMPRESSION_BC_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean occlusionQueryPrecise() {
		return (int) INT_HANDLE.get(this.segment, this.offset + OCCLUSION_QUERY_PRECISE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures occlusionQueryPrecise(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + OCCLUSION_QUERY_PRECISE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean pipelineStatisticsQuery() {
		return (int) INT_HANDLE.get(this.segment, this.offset + PIPELINE_STATISTICS_QUERY_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures pipelineStatisticsQuery(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + PIPELINE_STATISTICS_QUERY_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean vertexPipelineStoresAndAtomics() {
		return (int) INT_HANDLE.get(this.segment, this.offset + VERTEX_PIPELINE_STORES_AND_ATOMICS_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures vertexPipelineStoresAndAtomics(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + VERTEX_PIPELINE_STORES_AND_ATOMICS_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean fragmentStoresAndAtomics() {
		return (int) INT_HANDLE.get(this.segment, this.offset + FRAGMENT_STORES_AND_ATOMICS_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures fragmentStoresAndAtomics(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + FRAGMENT_STORES_AND_ATOMICS_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderTessellationAndGeometryPointSize() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_TESSELLATION_AND_GEOMETRY_POINT_SIZE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderTessellationAndGeometryPointSize(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_TESSELLATION_AND_GEOMETRY_POINT_SIZE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderImageGatherExtended() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_IMAGE_GATHER_EXTENDED_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderImageGatherExtended(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_IMAGE_GATHER_EXTENDED_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderStorageImageExtendedFormats() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_STORAGE_IMAGE_EXTENDED_FORMATS_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderStorageImageExtendedFormats(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_STORAGE_IMAGE_EXTENDED_FORMATS_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderStorageImageMultisample() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_STORAGE_IMAGE_MULTISAMPLE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderStorageImageMultisample(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_STORAGE_IMAGE_MULTISAMPLE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderStorageImageReadWithoutFormat() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_STORAGE_IMAGE_READ_WITHOUT_FORMAT_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderStorageImageReadWithoutFormat(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_STORAGE_IMAGE_READ_WITHOUT_FORMAT_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderStorageImageWriteWithoutFormat() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_STORAGE_IMAGE_WRITE_WITHOUT_FORMAT_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderStorageImageWriteWithoutFormat(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_STORAGE_IMAGE_WRITE_WITHOUT_FORMAT_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderUniformBufferArrayDynamicIndexing() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_UNIFORM_BUFFER_ARRAY_DYNAMIC_INDEXING_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderUniformBufferArrayDynamicIndexing(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_UNIFORM_BUFFER_ARRAY_DYNAMIC_INDEXING_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderSampledImageArrayDynamicIndexing() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_SAMPLED_IMAGE_ARRAY_DYNAMIC_INDEXING_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderSampledImageArrayDynamicIndexing(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_SAMPLED_IMAGE_ARRAY_DYNAMIC_INDEXING_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderStorageBufferArrayDynamicIndexing() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_STORAGE_BUFFER_ARRAY_DYNAMIC_INDEXING_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderStorageBufferArrayDynamicIndexing(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_STORAGE_BUFFER_ARRAY_DYNAMIC_INDEXING_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderStorageImageArrayDynamicIndexing() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_STORAGE_IMAGE_ARRAY_DYNAMIC_INDEXING_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderStorageImageArrayDynamicIndexing(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_STORAGE_IMAGE_ARRAY_DYNAMIC_INDEXING_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderClipDistance() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_CLIP_DISTANCE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderClipDistance(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_CLIP_DISTANCE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderCullDistance() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_CULL_DISTANCE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderCullDistance(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_CULL_DISTANCE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderFloat64() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_FLOAT64_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderFloat64(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_FLOAT64_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderInt64() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_INT64_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderInt64(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_INT64_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderInt16() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_INT16_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderInt16(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_INT16_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderResourceResidency() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_RESOURCE_RESIDENCY_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderResourceResidency(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_RESOURCE_RESIDENCY_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean shaderResourceMinLod() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SHADER_RESOURCE_MIN_LOD_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures shaderResourceMinLod(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SHADER_RESOURCE_MIN_LOD_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseBinding() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_BINDING_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseBinding(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_BINDING_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidencyBuffer() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY_BUFFER_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidencyBuffer(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY_BUFFER_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidencyImage2D() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY_IMAGE2_D_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidencyImage2D(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY_IMAGE2_D_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidencyImage3D() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY_IMAGE3_D_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidencyImage3D(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY_IMAGE3_D_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidency2Samples() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY2_SAMPLES_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidency2Samples(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY2_SAMPLES_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidency4Samples() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY4_SAMPLES_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidency4Samples(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY4_SAMPLES_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidency8Samples() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY8_SAMPLES_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidency8Samples(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY8_SAMPLES_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidency16Samples() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY16_SAMPLES_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidency16Samples(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY16_SAMPLES_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean sparseResidencyAliased() {
		return (int) INT_HANDLE.get(this.segment, this.offset + SPARSE_RESIDENCY_ALIASED_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures sparseResidencyAliased(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + SPARSE_RESIDENCY_ALIASED_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean variableMultisampleRate() {
		return (int) INT_HANDLE.get(this.segment, this.offset + VARIABLE_MULTISAMPLE_RATE_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures variableMultisampleRate(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + VARIABLE_MULTISAMPLE_RATE_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	@NativeType("VkBool32")
	public boolean inheritedQueries() {
		return (int) INT_HANDLE.get(this.segment, this.offset + INHERITED_QUERIES_OFFSET) != 0;
	}
	
	@NativeType("VkBool32")
	public VkPhysicalDeviceFeatures inheritedQueries(boolean value) {
		INT_HANDLE.set(this.segment, this.offset + INHERITED_QUERIES_OFFSET, value ? (int) 1 : (int) 0);
		return this;
	}
	
	
	@AutoGenerated
	public static final class Array extends VkStructArray<VkPhysicalDeviceFeatures> {
		
		private static final StructConstructor<VkPhysicalDeviceFeatures> CONSTRUCTOR = VkPhysicalDeviceFeatures::new;
		
		public Array(int size) {
			super(Arena.ofAuto(), new VkPhysicalDeviceFeatures[size], CONSTRUCTOR, MEMORY_LAYOUT);
		}
		
		public Array(Arena arena, int size) {
			super(arena, new VkPhysicalDeviceFeatures[size], CONSTRUCTOR, MEMORY_LAYOUT);
		}
		
		public Array(MemorySegment segment, long offset, int size) {
			super(segment, offset, new VkPhysicalDeviceFeatures[size], CONSTRUCTOR, MEMORY_LAYOUT);
		}
		
	}
	
	@Override
	public int getAlignment() {
		return (int) MEMORY_LAYOUT.byteAlignment();
	}
	
	@Override
	public int getSize() {
		return (int) MEMORY_LAYOUT.byteSize();
	}
	
}