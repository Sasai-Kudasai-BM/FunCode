package net.skds.jvk.generated.extensions;

import java.lang.invoke.MethodHandle;
import net.skds.jvk.VkDefinitions;
import net.skds.jvk.annotation.NativeType;
import net.skds.lib2.annotations.AutoGenerated;

import static net.skds.lib2.natives.SafeLinker.*;

@AutoGenerated
public final class VkKhrSwapchain {
	
	public static final int VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000;
	public static final int VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001;
	public static final int VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002;
	public static final int VK_SUBOPTIMAL_KHR = 1000001003;
	public static final int VK_ERROR_OUT_OF_DATE_KHR = 1000001004;
	public static final int VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000;
	private static final MethodHandle vkCreateSwapchainKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkCreateSwapchainKHR", INT, LONG, LONG, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_COMPRESSION_EXHAUSTED_EXT
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkCreateSwapchainKHR(@NativeType("VkDevice*") long device, @NativeType("VkSwapchainCreateInfoKHR*") long pCreateInfo, /* optional */ @NativeType("VkAllocationCallbacks*") long pAllocator, @NativeType("VkSwapchainKHR**") long pSwapchain) {
		try {
			return (int) vkCreateSwapchainKHR.invokeExact(device, pCreateInfo, pAllocator, pSwapchain);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	private static final MethodHandle vkDestroySwapchainKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkDestroySwapchainKHR", VOID, LONG, LONG, LONG);
	
	@NativeType("void")
	public static void vkDestroySwapchainKHR(@NativeType("VkDevice*") long device, /* optional, external sync */ @NativeType("VkSwapchainKHR*") long swapchain, /* optional */ @NativeType("VkAllocationCallbacks*") long pAllocator) {
		try {
			vkDestroySwapchainKHR.invokeExact(device, swapchain, pAllocator);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	private static final MethodHandle vkGetSwapchainImagesKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkGetSwapchainImagesKHR", INT, LONG, LONG, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS,VK_INCOMPLETE
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkGetSwapchainImagesKHR(@NativeType("VkDevice*") long device, @NativeType("VkSwapchainKHR*") long swapchain, /* optional */ @NativeType("uint32_t*") long pSwapchainImageCount, /* optional */ @NativeType("VkImage**") long pSwapchainImages) {
		try {
			return (int) vkGetSwapchainImagesKHR.invokeExact(device, swapchain, pSwapchainImageCount, pSwapchainImages);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	private static final MethodHandle vkAcquireNextImageKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkAcquireNextImageKHR", INT, LONG, LONG, LONG, LONG, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkAcquireNextImageKHR(@NativeType("VkDevice*") long device, /* external sync */ @NativeType("VkSwapchainKHR*") long swapchain, @NativeType("uint64_t") long timeout, /* optional, external sync */ @NativeType("VkSemaphore*") long semaphore, /* optional, external sync */ @NativeType("VkFence*") long fence, @NativeType("uint32_t*") long pImageIndex) {
		try {
			return (int) vkAcquireNextImageKHR.invokeExact(device, swapchain, timeout, semaphore, fence, pImageIndex);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	private static final MethodHandle vkQueuePresentKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkQueuePresentKHR", INT, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS,VK_SUBOPTIMAL_KHR
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkQueuePresentKHR(/* external sync */ @NativeType("VkQueue*") long queue, @NativeType("VkPresentInfoKHR*") long pPresentInfo) {
		try {
			return (int) vkQueuePresentKHR.invokeExact(queue, pPresentInfo);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	// This duplicates definitions in VK_KHR_device_group below
	
	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007;
	public static final int VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008;
	public static final int VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009;
	public static final int VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010;
	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011;
	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012;
	
	// Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
	
	/** Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT **/
	public static final int VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1;
	private static final MethodHandle vkGetDeviceGroupPresentCapabilitiesKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkGetDeviceGroupPresentCapabilitiesKHR", INT, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkGetDeviceGroupPresentCapabilitiesKHR(@NativeType("VkDevice*") long device, @NativeType("VkDeviceGroupPresentCapabilitiesKHR*") long pDeviceGroupPresentCapabilities) {
		try {
			return (int) vkGetDeviceGroupPresentCapabilitiesKHR.invokeExact(device, pDeviceGroupPresentCapabilities);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	private static final MethodHandle vkGetDeviceGroupSurfacePresentModesKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkGetDeviceGroupSurfacePresentModesKHR", INT, LONG, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkGetDeviceGroupSurfacePresentModesKHR(@NativeType("VkDevice*") long device, /* external sync */ @NativeType("VkSurfaceKHR*") long surface, /* optional */ @NativeType("VkDeviceGroupPresentModeFlagsKHR*") long pModes) {
		try {
			return (int) vkGetDeviceGroupSurfacePresentModesKHR.invokeExact(device, surface, pModes);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	private static final MethodHandle vkGetPhysicalDevicePresentRectanglesKHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDevicePresentRectanglesKHR", INT, LONG, LONG, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS,VK_INCOMPLETE
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkGetPhysicalDevicePresentRectanglesKHR(@NativeType("VkPhysicalDevice*") long physicalDevice, /* external sync */ @NativeType("VkSurfaceKHR*") long surface, /* optional */ @NativeType("uint32_t*") long pRectCount, /* optional */ @NativeType("VkRect2D*") long pRects) {
		try {
			return (int) vkGetPhysicalDevicePresentRectanglesKHR.invokeExact(physicalDevice, surface, pRectCount, pRects);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	private static final MethodHandle vkAcquireNextImage2KHR = createHandle(VkDefinitions.LIBRARY_LOOKUP, "vkAcquireNextImage2KHR", INT, LONG, LONG, LONG);
	
	/**
	*<pre>
	* successcodes = VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
	*</pre>
	**/
	@NativeType("VkResult")
	public static int vkAcquireNextImage2KHR(@NativeType("VkDevice*") long device, @NativeType("VkAcquireNextImageInfoKHR*") long pAcquireInfo, @NativeType("uint32_t*") long pImageIndex) {
		try {
			return (int) vkAcquireNextImage2KHR.invokeExact(device, pAcquireInfo, pImageIndex);
		} catch (Throwable e) {
			throw new Error(e);
		}
	}
	
	
	// Swapchain is protected
	
	/** Swapchain is protected **/
	public static final int VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 2;
}