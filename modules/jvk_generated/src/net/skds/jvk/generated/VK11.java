package net.skds.jvk.generated;
import net.skds.lib2.annotations.AutoGenerated;
import static net.skds.lib2.natives.SafeLinker.*;
import net.skds.jvk.VKDefinitions;
import net.skds.jvk.annotation.NativeType;
import java.lang.invoke.MethodHandle;

@AutoGenerated
public sealed class VK11 extends VK10 permits VK12 {


	// Device Initialization

	private static final MethodHandle vkEnumerateInstanceVersion = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkEnumerateInstanceVersion", INT, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY
	*/
	@NativeType("VkResult")
	public static int vkEnumerateInstanceVersion(@NativeType("uint32_t*") long pApiVersion) {
		try {
			return (int) vkEnumerateInstanceVersion.invokeExact(pApiVersion);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_relaxed_block_layout, which has no API

	// Promoted from VK_KHR_storage_buffer_storage_class, which has no API

	// Originally based on VK_KHR_subgroup (extension 94), but the actual enum block used was, incorrectly, that of extension 95

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 0;

	// Promoted from VK_KHR_bind_memory2

	private static final MethodHandle vkBindBufferMemory2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkBindBufferMemory2", INT, LONG, INT, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR
	*/
	@NativeType("VkResult")
	public static int vkBindBufferMemory2(@NativeType("VkDevice*") long device, @NativeType("uint32_t") int bindInfoCount, @NativeType("VkBindBufferMemoryInfo*") long pBindInfos) {
		try {
			return (int) vkBindBufferMemory2.invokeExact(device, bindInfoCount, pBindInfos);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkBindImageMemory2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkBindImageMemory2", INT, LONG, INT, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*/
	@NativeType("VkResult")
	public static int vkBindImageMemory2(@NativeType("VkDevice*") long device, @NativeType("uint32_t") int bindInfoCount, @NativeType("VkBindImageMemoryInfo*") long pBindInfos) {
		try {
			return (int) vkBindImageMemory2.invokeExact(device, bindInfoCount, pBindInfos);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	public static final int VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1;

	public static final int VK_IMAGE_CREATE_ALIAS_BIT = 1024;

	// Promoted from VK_KHR_16bit_storage

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 0;

	// Promoted from VK_KHR_dedicated_allocation

	public static final int VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 0;

	public static final int VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1;

	// Promoted from VK_KHR_device_group

	public static final int VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 0;

	// offset 1 reserved for the old VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX enum

	// offset 2 reserved for the old VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX enum

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 3;

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 4;

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 5;

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 6;

	private static final MethodHandle vkGetDeviceGroupPeerMemoryFeatures = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetDeviceGroupPeerMemoryFeatures", VOID, LONG, INT, INT, INT, LONG);

	@NativeType("void")
	public static void vkGetDeviceGroupPeerMemoryFeatures(@NativeType("VkDevice*") long device, @NativeType("uint32_t") int heapIndex, @NativeType("uint32_t") int localDeviceIndex, @NativeType("uint32_t") int remoteDeviceIndex, @NativeType("VkPeerMemoryFeatureFlags*") long pPeerMemoryFeatures) {
		try {
			vkGetDeviceGroupPeerMemoryFeatures.invokeExact(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkCmdSetDeviceMask = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkCmdSetDeviceMask", VOID, LONG, INT);

	@NativeType("void")
	public static void vkCmdSetDeviceMask(@NativeType("VkCommandBuffer*") /*external sync*/ long commandBuffer, @NativeType("uint32_t") int deviceMask) {
		try {
			vkCmdSetDeviceMask.invokeExact(commandBuffer, deviceMask);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkCmdDispatchBase = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkCmdDispatchBase", VOID, LONG, INT, INT, INT, INT, INT, INT);

	@NativeType("void")
	public static void vkCmdDispatchBase(@NativeType("VkCommandBuffer*") /*external sync*/ long commandBuffer, @NativeType("uint32_t") int baseGroupX, @NativeType("uint32_t") int baseGroupY, @NativeType("uint32_t") int baseGroupZ, @NativeType("uint32_t") int groupCountX, @NativeType("uint32_t") int groupCountY, @NativeType("uint32_t") int groupCountZ) {
		try {
			vkCmdDispatchBase.invokeExact(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	public static final int VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 8;

	public static final int VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 16;

	public static final int VK_PIPELINE_CREATE_DISPATCH_BASE = 16;

	// Dependency is across devices

	/**
	* Dependency is across devices
	*/
	public static final int VK_DEPENDENCY_DEVICE_GROUP_BIT = 4;

	// Promoted from VK_KHR_device_group + VK_KHR_bind_memory2

	public static final int VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 13;

	public static final int VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 14;

	// Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image

	/**
	* Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image
	*/
	public static final int VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 64;

	// Promoted from VK_KHR_device_group_creation

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 0;

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1;

	public static final int VK_MAX_DEVICE_GROUP_SIZE = 32;

	private static final MethodHandle vkEnumeratePhysicalDeviceGroups = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkEnumeratePhysicalDeviceGroups", INT, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS,VK_INCOMPLETE
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED
	*/
	@NativeType("VkResult")
	public static int vkEnumeratePhysicalDeviceGroups(@NativeType("VkInstance*") long instance, @NativeType("uint32_t*") /*optional*/ long pPhysicalDeviceGroupCount, @NativeType("VkPhysicalDeviceGroupProperties*") /*optional*/ long pPhysicalDeviceGroupProperties) {
		try {
			return (int) vkEnumeratePhysicalDeviceGroups.invokeExact(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// If set, heap allocations allocate multiple instances by default

	/**
	* If set, heap allocations allocate multiple instances by default
	*/
	public static final int VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 2;

	// Promoted from VK_KHR_get_memory_requirements2

	public static final int VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 0;

	public static final int VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1;

	public static final int VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 2;

	public static final int VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 3;

	public static final int VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 4;

	private static final MethodHandle vkGetImageMemoryRequirements2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetImageMemoryRequirements2", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetImageMemoryRequirements2(@NativeType("VkDevice*") long device, @NativeType("VkImageMemoryRequirementsInfo2*") long pInfo, @NativeType("VkMemoryRequirements2*") long pMemoryRequirements) {
		try {
			vkGetImageMemoryRequirements2.invokeExact(device, pInfo, pMemoryRequirements);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetBufferMemoryRequirements2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetBufferMemoryRequirements2", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetBufferMemoryRequirements2(@NativeType("VkDevice*") long device, @NativeType("VkBufferMemoryRequirementsInfo2*") long pInfo, @NativeType("VkMemoryRequirements2*") long pMemoryRequirements) {
		try {
			vkGetBufferMemoryRequirements2.invokeExact(device, pInfo, pMemoryRequirements);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetImageSparseMemoryRequirements2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetImageSparseMemoryRequirements2", VOID, LONG, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetImageSparseMemoryRequirements2(@NativeType("VkDevice*") long device, @NativeType("VkImageSparseMemoryRequirementsInfo2*") long pInfo, @NativeType("uint32_t*") /*optional*/ long pSparseMemoryRequirementCount, @NativeType("VkSparseImageMemoryRequirements2*") /*optional*/ long pSparseMemoryRequirements) {
		try {
			vkGetImageSparseMemoryRequirements2.invokeExact(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_get_physical_device_properties2

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 0;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1;

	public static final int VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 2;

	public static final int VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 3;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 4;

	public static final int VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 5;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 6;

	public static final int VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 7;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 8;

	private static final MethodHandle vkGetPhysicalDeviceFeatures2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceFeatures2", VOID, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceFeatures2(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceFeatures2*") long pFeatures) {
		try {
			vkGetPhysicalDeviceFeatures2.invokeExact(physicalDevice, pFeatures);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetPhysicalDeviceProperties2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceProperties2", VOID, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceProperties2(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceProperties2*") long pProperties) {
		try {
			vkGetPhysicalDeviceProperties2.invokeExact(physicalDevice, pProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetPhysicalDeviceFormatProperties2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceFormatProperties2", VOID, LONG, INT, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceFormatProperties2(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkFormat") int format, @NativeType("VkFormatProperties2*") long pFormatProperties) {
		try {
			vkGetPhysicalDeviceFormatProperties2.invokeExact(physicalDevice, format, pFormatProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetPhysicalDeviceImageFormatProperties2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceImageFormatProperties2", INT, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED
	*/
	@NativeType("VkResult")
	public static int vkGetPhysicalDeviceImageFormatProperties2(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceImageFormatInfo2*") long pImageFormatInfo, @NativeType("VkImageFormatProperties2*") long pImageFormatProperties) {
		try {
			return (int) vkGetPhysicalDeviceImageFormatProperties2.invokeExact(physicalDevice, pImageFormatInfo, pImageFormatProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetPhysicalDeviceQueueFamilyProperties2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceQueueFamilyProperties2", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceQueueFamilyProperties2(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("uint32_t*") /*optional*/ long pQueueFamilyPropertyCount, @NativeType("VkQueueFamilyProperties2*") /*optional*/ long pQueueFamilyProperties) {
		try {
			vkGetPhysicalDeviceQueueFamilyProperties2.invokeExact(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetPhysicalDeviceMemoryProperties2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceMemoryProperties2", VOID, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceMemoryProperties2(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceMemoryProperties2*") long pMemoryProperties) {
		try {
			vkGetPhysicalDeviceMemoryProperties2.invokeExact(physicalDevice, pMemoryProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetPhysicalDeviceSparseImageFormatProperties2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceSparseImageFormatProperties2", VOID, LONG, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceSparseImageFormatProperties2(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceSparseImageFormatInfo2*") long pFormatInfo, @NativeType("uint32_t*") /*optional*/ long pPropertyCount, @NativeType("VkSparseImageFormatProperties2*") /*optional*/ long pProperties) {
		try {
			vkGetPhysicalDeviceSparseImageFormatProperties2.invokeExact(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_maintenance1

	public static final int VK_ERROR_OUT_OF_POOL_MEMORY = 0;

	// Format can be used as the source image of image transfer commands

	/**
	* Format can be used as the source image of image transfer commands
	*/
	public static final int VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 16384;

	// Format can be used as the destination image of image transfer commands

	/**
	* Format can be used as the destination image of image transfer commands
	*/
	public static final int VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 32768;

	// The 3D image can be viewed as a 2D or 2D array image

	/**
	* The 3D image can be viewed as a 2D or 2D array image
	*/
	public static final int VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 32;

	private static final MethodHandle vkTrimCommandPool = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkTrimCommandPool", VOID, LONG, LONG, INT);

	@NativeType("void")
	public static void vkTrimCommandPool(@NativeType("VkDevice*") long device, @NativeType("VkCommandPool*") /*external sync*/ long commandPool, @NativeType("VkCommandPoolTrimFlags") /*optional*/ int flags) {
		try {
			vkTrimCommandPool.invokeExact(device, commandPool, flags);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Additional dependent types / tokens extending enumerants, not explicitly mentioned

	// Promoted from VK_KHR_maintenance2

	public static final int VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 128;

	public static final int VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 256;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 0;

	public static final int VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1;

	public static final int VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 2;

	public static final int VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 3;

	public static final int VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 0;

	public static final int VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1;

	// Promoted from VK_KHR_multiview

	public static final int VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 2;

	public static final int VK_DEPENDENCY_VIEW_LOCAL_BIT = 2;

	// Promoted from VK_KHR_variable_pointers

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 0;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 0;

	// Originally based on VK_KHR_protected_memory (extension 146), which was never published; thus the mystifying large value= numbers below. These are not aliased since they were not actually promoted from an extension.

	public static final int VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 2;

	public static final int VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 3;

	// Queues may support protected operations

	/**
	* Queues may support protected operations
	*/
	public static final int VK_QUEUE_PROTECTED_BIT = 16;

	// Queue is a protected-capable device queue

	/**
	* Queue is a protected-capable device queue
	*/
	public static final int VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 1;

	// This is a temporary workaround for processors not recognizing that VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT above also requires this type

	// Memory is protected

	/**
	* Memory is protected
	*/
	public static final int VK_MEMORY_PROPERTY_PROTECTED_BIT = 32;

	// Buffer requires protected memory

	/**
	* Buffer requires protected memory
	*/
	public static final int VK_BUFFER_CREATE_PROTECTED_BIT = 8;

	// Image requires protected memory

	/**
	* Image requires protected memory
	*/
	public static final int VK_IMAGE_CREATE_PROTECTED_BIT = 2048;

	// Command buffers allocated from pool are protected command buffers

	/**
	* Command buffers allocated from pool are protected command buffers
	*/
	public static final int VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 4;

	private static final MethodHandle vkGetDeviceQueue2 = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetDeviceQueue2", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetDeviceQueue2(@NativeType("VkDevice*") long device, @NativeType("VkDeviceQueueInfo2*") long pQueueInfo, @NativeType("VkQueue**") long pQueue) {
		try {
			vkGetDeviceQueue2.invokeExact(device, pQueueInfo, pQueue);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_sampler_ycbcr_conversion

	public static final int VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1;

	public static final int VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 2;

	public static final int VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 3;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 4;

	public static final int VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 5;

	public static final int VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 0;

	public static final int VK_FORMAT_G8B8G8R8_422_UNORM = 0;

	public static final int VK_FORMAT_B8G8R8G8_422_UNORM = 1;

	public static final int VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 2;

	public static final int VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 3;

	public static final int VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 4;

	public static final int VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 5;

	public static final int VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 6;

	public static final int VK_FORMAT_R10X6_UNORM_PACK16 = 7;

	public static final int VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 8;

	public static final int VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 9;

	public static final int VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 10;

	public static final int VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 11;

	public static final int VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 12;

	public static final int VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 13;

	public static final int VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 14;

	public static final int VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 15;

	public static final int VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 16;

	public static final int VK_FORMAT_R12X4_UNORM_PACK16 = 17;

	public static final int VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 18;

	public static final int VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 19;

	public static final int VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 20;

	public static final int VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 21;

	public static final int VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 22;

	public static final int VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 23;

	public static final int VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 24;

	public static final int VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 25;

	public static final int VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 26;

	public static final int VK_FORMAT_G16B16G16R16_422_UNORM = 27;

	public static final int VK_FORMAT_B16G16R16G16_422_UNORM = 28;

	public static final int VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 29;

	public static final int VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 30;

	public static final int VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 31;

	public static final int VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 32;

	public static final int VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 33;

	public static final int VK_IMAGE_ASPECT_PLANE_0_BIT = 16;

	public static final int VK_IMAGE_ASPECT_PLANE_1_BIT = 32;

	public static final int VK_IMAGE_ASPECT_PLANE_2_BIT = 64;

	public static final int VK_IMAGE_CREATE_DISJOINT_BIT = 512;

	// Format can have midpoint rather than cosited chroma samples

	/**
	* Format can have midpoint rather than cosited chroma samples
	*/
	public static final int VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 131072;

	// Format can be used with linear filtering whilst color conversion is enabled

	/**
	* Format can be used with linear filtering whilst color conversion is enabled
	*/
	public static final int VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 262144;

	// Format can have different chroma, min and mag filters

	/**
	* Format can have different chroma, min and mag filters
	*/
	public static final int VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 524288;

	public static final int VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1048576;

	public static final int VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 2097152;

	// Format supports disjoint planes

	/**
	* Format supports disjoint planes
	*/
	public static final int VK_FORMAT_FEATURE_DISJOINT_BIT = 4194304;

	// Format can have cosited rather than midpoint chroma samples

	/**
	* Format can have cosited rather than midpoint chroma samples
	*/
	public static final int VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 8388608;

	private static final MethodHandle vkCreateSamplerYcbcrConversion = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkCreateSamplerYcbcrConversion", INT, LONG, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*/
	@NativeType("VkResult")
	public static int vkCreateSamplerYcbcrConversion(@NativeType("VkDevice*") long device, @NativeType("VkSamplerYcbcrConversionCreateInfo*") long pCreateInfo, @NativeType("VkAllocationCallbacks*") /*optional*/ long pAllocator, @NativeType("VkSamplerYcbcrConversion**") long pYcbcrConversion) {
		try {
			return (int) vkCreateSamplerYcbcrConversion.invokeExact(device, pCreateInfo, pAllocator, pYcbcrConversion);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkDestroySamplerYcbcrConversion = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkDestroySamplerYcbcrConversion", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkDestroySamplerYcbcrConversion(@NativeType("VkDevice*") long device, @NativeType("VkSamplerYcbcrConversion*") /*optional, external sync*/ long ycbcrConversion, @NativeType("VkAllocationCallbacks*") /*optional*/ long pAllocator) {
		try {
			vkDestroySamplerYcbcrConversion.invokeExact(device, ycbcrConversion, pAllocator);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Additional dependent types / tokens extending enumerants, not explicitly mentioned

	// Promoted from VK_KHR_descriptor_update_template

	public static final int VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 0;

	public static final int VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 0;

	private static final MethodHandle vkCreateDescriptorUpdateTemplate = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkCreateDescriptorUpdateTemplate", INT, LONG, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*/
	@NativeType("VkResult")
	public static int vkCreateDescriptorUpdateTemplate(@NativeType("VkDevice*") long device, @NativeType("VkDescriptorUpdateTemplateCreateInfo*") long pCreateInfo, @NativeType("VkAllocationCallbacks*") /*optional*/ long pAllocator, @NativeType("VkDescriptorUpdateTemplate**") long pDescriptorUpdateTemplate) {
		try {
			return (int) vkCreateDescriptorUpdateTemplate.invokeExact(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkDestroyDescriptorUpdateTemplate = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkDestroyDescriptorUpdateTemplate", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkDestroyDescriptorUpdateTemplate(@NativeType("VkDevice*") long device, @NativeType("VkDescriptorUpdateTemplate*") /*optional, external sync*/ long descriptorUpdateTemplate, @NativeType("VkAllocationCallbacks*") /*optional*/ long pAllocator) {
		try {
			vkDestroyDescriptorUpdateTemplate.invokeExact(device, descriptorUpdateTemplate, pAllocator);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkUpdateDescriptorSetWithTemplate = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkUpdateDescriptorSetWithTemplate", VOID, LONG, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkUpdateDescriptorSetWithTemplate(@NativeType("VkDevice*") long device, @NativeType("VkDescriptorSet*") /*external sync*/ long descriptorSet, @NativeType("VkDescriptorUpdateTemplate*") long descriptorUpdateTemplate, @NativeType("void*") long pData) {
		try {
			vkUpdateDescriptorSetWithTemplate.invokeExact(device, descriptorSet, descriptorUpdateTemplate, pData);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_external_memory_capabilities

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 2;

	public static final int VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 3;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 4;

	public static final int VK_LUID_SIZE = 8;

	private static final MethodHandle vkGetPhysicalDeviceExternalBufferProperties = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceExternalBufferProperties", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceExternalBufferProperties(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceExternalBufferInfo*") long pExternalBufferInfo, @NativeType("VkExternalBufferProperties*") long pExternalBufferProperties) {
		try {
			vkGetPhysicalDeviceExternalBufferProperties.invokeExact(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_external_memory

	public static final int VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1;

	public static final int VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 2;

	public static final int VK_ERROR_INVALID_EXTERNAL_HANDLE = 3;

	public static final int VK_QUEUE_FAMILY_EXTERNAL = 1;

	// Promoted from VK_KHR_external_fence_capabilities

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1;

	private static final MethodHandle vkGetPhysicalDeviceExternalFenceProperties = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceExternalFenceProperties", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceExternalFenceProperties(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceExternalFenceInfo*") long pExternalFenceInfo, @NativeType("VkExternalFenceProperties*") long pExternalFenceProperties) {
		try {
			vkGetPhysicalDeviceExternalFenceProperties.invokeExact(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_external_fence

	public static final int VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 0;

	// Promoted from VK_KHR_external_semaphore

	public static final int VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 0;

	// Promoted from VK_KHR_external_semaphore_capabilities

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 0;

	public static final int VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1;

	private static final MethodHandle vkGetPhysicalDeviceExternalSemaphoreProperties = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetPhysicalDeviceExternalSemaphoreProperties", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetPhysicalDeviceExternalSemaphoreProperties(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkPhysicalDeviceExternalSemaphoreInfo*") long pExternalSemaphoreInfo, @NativeType("VkExternalSemaphoreProperties*") long pExternalSemaphoreProperties) {
		try {
			vkGetPhysicalDeviceExternalSemaphoreProperties.invokeExact(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_maintenance3

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 0;

	public static final int VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1;

	private static final MethodHandle vkGetDescriptorSetLayoutSupport = createHandle(VKDefinitions.LIBRARY_LOOKUP, "vkGetDescriptorSetLayoutSupport", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkGetDescriptorSetLayoutSupport(@NativeType("VkDevice*") long device, @NativeType("VkDescriptorSetLayoutCreateInfo*") long pCreateInfo, @NativeType("VkDescriptorSetLayoutSupport*") long pSupport) {
		try {
			vkGetDescriptorSetLayoutSupport.invokeExact(device, pCreateInfo, pSupport);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Promoted from VK_KHR_shader_draw_parameters, with a feature support query added

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 0;

	public static final int VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 0;
}