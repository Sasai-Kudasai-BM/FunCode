package net.skds.jvk.generated.extensions;
import net.skds.jvk.annotation.NativeType;
import static net.skds.ninvoker.NInvoker.*;
import java.lang.invoke.MethodHandle;
import net.skds.jvk.VKDefinitions;
import net.skds.lib.utils.annotations.AutoGenerated;

@AutoGenerated
@SuppressWarnings("unused")
public final class VkKhrSwapchain {


	public static final boolean INITIALIZED = VKDefinitions.INITIALIZED;

	public static final int VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 0;

	public static final int VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1;

	public static final int VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 2;

	public static final int VK_SUBOPTIMAL_KHR = 3;

	public static final int VK_ERROR_OUT_OF_DATE_KHR = 4;

	public static final int VK_OBJECT_TYPE_SWAPCHAIN_KHR = 0;

	private static final MethodHandle vkCreateSwapchainKHR = createHandle("vkCreateSwapchainKHR", INT, LONG, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_COMPRESSION_EXHAUSTED_EXT
	*/
	@NativeType("VkResult")
	public static int vkCreateSwapchainKHR(@NativeType("VkDevice*") long device, @NativeType("VkSwapchainCreateInfoKHR*") /*external sync*/ long pCreateInfo, @NativeType("VkAllocationCallbacks*") /*optional*/ long pAllocator, @NativeType("VkSwapchainKHR**") long pSwapchain) {
		try {
			return (int) vkCreateSwapchainKHR.invokeExact(device, pCreateInfo, pAllocator, pSwapchain);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkDestroySwapchainKHR = createHandle("vkDestroySwapchainKHR", VOID, LONG, LONG, LONG);

	@NativeType("void")
	public static void vkDestroySwapchainKHR(@NativeType("VkDevice*") long device, @NativeType("VkSwapchainKHR*") /*optional, external sync*/ long swapchain, @NativeType("VkAllocationCallbacks*") /*optional*/ long pAllocator) {
		try {
			vkDestroySwapchainKHR.invokeExact(device, swapchain, pAllocator);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetSwapchainImagesKHR = createHandle("vkGetSwapchainImagesKHR", INT, LONG, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS,VK_INCOMPLETE
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*/
	@NativeType("VkResult")
	public static int vkGetSwapchainImagesKHR(@NativeType("VkDevice*") long device, @NativeType("VkSwapchainKHR*") long swapchain, @NativeType("uint32_t*") /*optional*/ long pSwapchainImageCount, @NativeType("VkImage**") /*optional*/ long pSwapchainImages) {
		try {
			return (int) vkGetSwapchainImagesKHR.invokeExact(device, swapchain, pSwapchainImageCount, pSwapchainImages);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkAcquireNextImageKHR = createHandle("vkAcquireNextImageKHR", INT, LONG, LONG, LONG, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
	*/
	@NativeType("VkResult")
	public static int vkAcquireNextImageKHR(@NativeType("VkDevice*") long device, @NativeType("VkSwapchainKHR*") /*external sync*/ long swapchain, @NativeType("uint64_t") long timeout, @NativeType("VkSemaphore*") /*optional, external sync*/ long semaphore, @NativeType("VkFence*") /*optional, external sync*/ long fence, @NativeType("uint32_t*") long pImageIndex) {
		try {
			return (int) vkAcquireNextImageKHR.invokeExact(device, swapchain, timeout, semaphore, fence, pImageIndex);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkQueuePresentKHR = createHandle("vkQueuePresentKHR", INT, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS,VK_SUBOPTIMAL_KHR
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
	*/
	@NativeType("VkResult")
	public static int vkQueuePresentKHR(@NativeType("VkQueue*") /*external sync*/ long queue, @NativeType("VkPresentInfoKHR*") /*external sync*/ long pPresentInfo) {
		try {
			return (int) vkQueuePresentKHR.invokeExact(queue, pPresentInfo);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// This duplicates definitions in VK_KHR_device_group below

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 7;

	public static final int VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 8;

	public static final int VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 9;

	public static final int VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 10;

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 11;

	public static final int VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 12;

	// Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT

	/**
	* Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
	*/
	public static final int VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1;

	private static final MethodHandle vkGetDeviceGroupPresentCapabilitiesKHR = createHandle("vkGetDeviceGroupPresentCapabilitiesKHR", INT, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*/
	@NativeType("VkResult")
	public static int vkGetDeviceGroupPresentCapabilitiesKHR(@NativeType("VkDevice*") long device, @NativeType("VkDeviceGroupPresentCapabilitiesKHR*") long pDeviceGroupPresentCapabilities) {
		try {
			return (int) vkGetDeviceGroupPresentCapabilitiesKHR.invokeExact(device, pDeviceGroupPresentCapabilities);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetDeviceGroupSurfacePresentModesKHR = createHandle("vkGetDeviceGroupSurfacePresentModesKHR", INT, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR
	*/
	@NativeType("VkResult")
	public static int vkGetDeviceGroupSurfacePresentModesKHR(@NativeType("VkDevice*") long device, @NativeType("VkSurfaceKHR*") /*external sync*/ long surface, @NativeType("VkDeviceGroupPresentModeFlagsKHR*") /*optional*/ long pModes) {
		try {
			return (int) vkGetDeviceGroupSurfacePresentModesKHR.invokeExact(device, surface, pModes);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkGetPhysicalDevicePresentRectanglesKHR = createHandle("vkGetPhysicalDevicePresentRectanglesKHR", INT, LONG, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS,VK_INCOMPLETE
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY
	*/
	@NativeType("VkResult")
	public static int vkGetPhysicalDevicePresentRectanglesKHR(@NativeType("VkPhysicalDevice*") long physicalDevice, @NativeType("VkSurfaceKHR*") /*external sync*/ long surface, @NativeType("uint32_t*") /*optional*/ long pRectCount, @NativeType("VkRect2D*") /*optional*/ long pRects) {
		try {
			return (int) vkGetPhysicalDevicePresentRectanglesKHR.invokeExact(physicalDevice, surface, pRectCount, pRects);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	private static final MethodHandle vkAcquireNextImage2KHR = createHandle("vkAcquireNextImage2KHR", INT, LONG, LONG, LONG);

	/**
	* successcodes = VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
	* errorcodes = VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
	*/
	@NativeType("VkResult")
	public static int vkAcquireNextImage2KHR(@NativeType("VkDevice*") long device, @NativeType("VkAcquireNextImageInfoKHR*") long pAcquireInfo, @NativeType("uint32_t*") long pImageIndex) {
		try {
			return (int) vkAcquireNextImage2KHR.invokeExact(device, pAcquireInfo, pImageIndex);
		} catch (Throwable e) { throw new RuntimeException(e); }
	}

	// Swapchain is protected

	/**
	* Swapchain is protected
	*/
	public static final int VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 2;
}