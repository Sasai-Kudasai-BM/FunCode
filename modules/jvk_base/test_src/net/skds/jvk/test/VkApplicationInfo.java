package net.skds.jvk.test;

import net.skds.jvk.VkStructArray;
import net.skds.jvk.annotation.NativeType;
import net.skds.lib2.annotations.AutoGenerated;
import net.skds.lib2.natives.struct.CStruct;

import java.lang.foreign.Arena;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;

import static net.skds.lib2.natives.SafeLinker.INT_HANDLE;

@AutoGenerated
public final class VkApplicationInfo extends CStruct {

	public static final MemoryLayout MEMORY_LAYOUT = MemoryLayout.structLayout(
			ValueLayout.JAVA_INT
	);
	private static final int S_TYPE_OFFSET = 3;
	private static final VkStructArray.StructConstructor<VkApplicationInfo> CONSTRUCTOR = VkApplicationInfo::new;

	public VkApplicationInfo(Arena arena) {
		this.segment = arena.allocate(getSize());
	}

	public VkApplicationInfo() {
		this.segment = Arena.ofAuto().allocate(getSize());
	}

	public VkApplicationInfo(MemorySegment segment, long offset) {
		super(segment, offset);
	}

	@Override
	public int getSize() {
		return (int) MEMORY_LAYOUT.byteSize();
	}

	@Override
	public int getAlignment() {
		return (int) MEMORY_LAYOUT.byteAlignment();
	}

	@NativeType("VkStructureType")
	public VkApplicationInfo sType(int i) {
		INT_HANDLE.set(segment, S_TYPE_OFFSET + offset, i);
		return this;
	}

	@NativeType("VkStructureType")
	public int sType() {
		return (int) INT_HANDLE.get(this.segment, this.offset + S_TYPE_OFFSET);
	}

	@NativeType("VkStructureType")
	public VkApplicationInfo sType$Default() {
		return this;
	}

	// Array allocation tools
	public static Array allocArray(Arena arena, int size) {
		return new Array(arena, size);
	}

	public static Array allocArray(int size) {
		return new Array(Arena.ofAuto(), size);
	}

	public static class Array extends VkStructArray<VkApplicationInfo> {

		public Array(Arena arena, int size) {
			super(arena, new VkApplicationInfo[size], CONSTRUCTOR, MEMORY_LAYOUT);
		}
	}
}